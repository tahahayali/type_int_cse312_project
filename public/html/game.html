<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Phaser Multiplayer Tag</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.js"></script>
  <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background-color: #111;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }
    canvas {
      display: block;
      max-width: 100%;
      max-height: 100%;
    }
  </style>
</head>
<body>
<script type="text/javascript">
class GameScene extends Phaser.Scene {
    constructor() {
        super('GameScene');
    }

    preload() {
        this.load.image('tiles', '/assets/tilemaps/tiles/buch-dungeon-tileset.png');
    }

    create() {
        this.tileSize = 16;
        this.scaleFactor = 3;
        const mapWidth = 60, mapHeight = 40;

        this.map = this.make.tilemap({
            tileWidth: this.tileSize,
            tileHeight: this.tileSize,
            width: mapWidth,
            height: mapHeight
        });
        const tiles = this.map.addTilesetImage('tiles');

        this.groundLayer = this.map.createBlankLayer('Ground', tiles).setScale(this.scaleFactor);
        this.objectLayer = this.map.createBlankLayer('Objects', tiles).setScale(this.scaleFactor);

        this.randomizeRoom();
        this.blockedTiles = new Set();
        this.recordBlockedTiles();

        this.socket = io();
        this.players = {};
        this.myID = null;
        this.isIt = false;

        const spawn = this.getSafeSpawn(mapWidth, mapHeight);
        this.player = this.add.circle(spawn.x, spawn.y, 16, 0x00ff00); // ðŸŸ¢ Circle player, 32px diameter
        this.lastX = this.player.x;
        this.lastY = this.player.y;

        this.cameras.main.startFollow(this.player);
        this.cameras.main.setBounds(
            0, 0,
            this.map.width * this.tileSize * this.scaleFactor,
            this.map.height * this.tileSize * this.scaleFactor
        );

        this.socket.emit("move", { x: this.player.x, y: this.player.y });

        this.socket.on("init", (data) => {
            this.myID = data.id;
            this.isIt = data.players[this.myID].it;
            this.updatePlayerColor();
            for (let id in data.players) {
                if (id !== this.myID) {
                    const p = data.players[id];
                    const color = p.it ? 0xff0000 : 0x0000ff;
                    this.players[id] = this.add.circle(p.x, p.y, 16, color);
                }
            }
        });

        this.socket.on("playerJoined", (data) => {
            const color = data.it ? 0xff0000 : 0x0000ff;
            this.players[data.id] = this.add.circle(data.x, data.y, 16, color);
        });

        this.socket.on("playerMoved", (data) => {
            if (data.id === this.myID) return;
            const player = this.players[data.id];
            if (!player) {
                this.players[data.id] = this.add.circle(data.x, data.y, 16, 0x0000ff);
            } else {
                player.x = data.x;
                player.y = data.y;
            }
        });

        this.socket.on("playerLeft", (data) => {
            if (this.players[data.id]) {
                this.players[data.id].destroy();
                delete this.players[data.id];
            }
        });

        this.socket.on("tagUpdate", (data) => {
            const { newIt, prevIt } = data;
            if (newIt === this.myID) {
                this.isIt = true;
                this.updatePlayerColor();
            } else if (prevIt === this.myID) {
                this.isIt = false;
                this.updatePlayerColor();
            }
            if (this.players[newIt]) this.players[newIt].setFillStyle(0xff0000);
            if (this.players[prevIt]) this.players[prevIt].setFillStyle(0x0000ff);
        });

        this.cursors = this.input.keyboard.createCursorKeys();
    }

    update() {
        const speed = 2.2;
        const tileSize = this.tileSize * this.scaleFactor;
        let moveX = 0, moveY = 0;

        if (this.cursors.left.isDown) moveX = -speed;
        else if (this.cursors.right.isDown) moveX = speed;
        if (this.cursors.up.isDown) moveY = -speed;
        else if (this.cursors.down.isDown) moveY = speed;

        const newX = this.player.x + moveX;
        const newY = this.player.y + moveY;

        const tileX_current = Math.floor(this.player.x / tileSize);
        const tileY_current = Math.floor(this.player.y / tileSize);
        const tileX_new = Math.floor(newX / tileSize);
        const tileY_new = Math.floor(newY / tileSize);

        const blockedX = this.blockedTiles.has(`${tileX_new},${tileY_current}`);
        const blockedY = this.blockedTiles.has(`${tileX_current},${tileY_new}`);

        let moved = false;

        if (!blockedX) {
            this.player.x = newX;
            moved = true;
        }

        if (!blockedY) {
            this.player.y = newY;
            moved = true;
        }

        if (moved) {
            this.socket.emit("move", { x: this.player.x, y: this.player.y });
        }

        if (this.isIt) {
            for (let id in this.players) {
                const other = this.players[id];
                if (!other) continue;
                const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, other.x, other.y);
                if (dist < 32) this.socket.emit("tag", { id });
            }
        }
    }


    updatePlayerColor() {
        const color = this.isIt ? 0xff0000 : 0x00ff00;
        this.player.setFillStyle(color);
    }

    randomizeRoom() {
        const w = this.map.width;
        const h = this.map.height;
        this.groundLayer.fill(39, 0, 0, w, 1);
        this.groundLayer.fill(1, 0, h - 1, w, 1);
        this.groundLayer.fill(21, 0, 0, 1, h);
        this.groundLayer.fill(19, w - 1, 0, 1, h);
        this.groundLayer.putTileAt(3, 0, 0);
        this.groundLayer.putTileAt(4, w - 1, 0);
        this.groundLayer.putTileAt(23, w - 1, h - 1);
        this.groundLayer.putTileAt(22, 0, h - 1);

        this.groundLayer.weightedRandomize([
            { index: 6, weight: 4 },
            { index: 7, weight: 1 },
            { index: 8, weight: 1 },
            { index: 26, weight: 1 }
        ], 1, 1, w - 2, h - 2);

        this.objectLayer.weightedRandomize([
            { index: -1, weight: 50 },
            { index: 13, weight: 3 },
            { index: 32, weight: 2 },
            { index: 127, weight: 1 },
            { index: 108, weight: 1 },
            { index: 109, weight: 2 },
            { index: 110, weight: 2 },
            { index: 166, weight: 0.25 },
            { index: 167, weight: 0.25 }
        ], 1, 1, w - 2, h - 2);
    }

    recordBlockedTiles() {
        this.blockedTiles.clear();
        const w = this.map.width, h = this.map.height;
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                const tile = this.objectLayer.getTileAt(x, y);
                if (!tile) continue;
                const blockIndexes = [13, 32, 127, 108, 109, 110, 166, 167];
                if (blockIndexes.includes(tile.index)) {
                    this.blockedTiles.add(`${x},${y}`);
                }
            }
        }
        for (let x = 0; x < w; x++) {
            this.blockedTiles.add(`${x},0`);
            this.blockedTiles.add(`${x},${h - 1}`);
        }
        for (let y = 0; y < h; y++) {
            this.blockedTiles.add(`0,${y}`);
            this.blockedTiles.add(`${w - 1},${y}`);
        }
    }

    getSafeSpawn(mapWidth, mapHeight) {
        let spawnX, spawnY, tileX, tileY;
        const tileSize = this.tileSize * this.scaleFactor;
        do {
            spawnX = Phaser.Math.Between(2, mapWidth - 3) * tileSize;
            spawnY = Phaser.Math.Between(2, mapHeight - 3) * tileSize;
            tileX = Math.floor(spawnX / tileSize);
            tileY = Math.floor(spawnY / tileSize);
        } while (this.blockedTiles.has(`${tileX},${tileY}`));
        return { x: spawnX, y: spawnY };
    }
}

const config = {
    type: Phaser.AUTO,
    width: window.innerWidth,
    height: window.innerHeight,
    backgroundColor: '#111',
    pixelArt: true,
    scene: GameScene,
    scale: {
        mode: Phaser.Scale.FIT,
        autoCenter: Phaser.Scale.CENTER_BOTH
    }
};

new Phaser.Game(config);
</script>
</body>
</html>
